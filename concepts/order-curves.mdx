---
title: Order Curves
description: 'The mathematical foundation: power-law density functions for continuous liquidity'
---

# Order Curves

Order curves are Braid's core innovation - a mathematical framework that unifies limit orders, concentrated liquidity, and AMM pools under a single representation. Instead of treating orders as discrete price points, Braid models liquidity as continuous curves over price ranges.

<Note>
**Key Insight**: Traditional orderbooks have discrete orders at specific prices. Order curves provide *continuous* liquidity distributions, enabling optimal allocation algorithms and eliminating the MEV opportunities created by discrete trigger prices.
</Note>

---

## The Problem with Discrete Orders

Traditional orderbooks have a fundamental vulnerability:

```
Traditional Orderbook                 The MEV Problem

ASKS                                  1. Large buy order incoming
$102.00 ████ 500                      2. Bot sees it in mempool
$101.50 ██████ 800                    3. Bot front-runs at $100.01
$101.00 ████████ 1200     ────────▶   4. Original order fills at $101+
$100.50 ██████████ 2000               5. Bot sells at profit
$100.00 ████████████ 3000
                                      Result: Trader pays more
BIDS
$99.50  ████████████ 2500
$99.00  ██████████ 1800
```

Each discrete price level creates a **trigger point** that MEV bots can exploit. When your order crosses a price level, bots can front-run to capture the difference.

---

## Order Curves: Continuous Liquidity

Braid replaces discrete orders with **order curves** - continuous functions that describe how liquidity is distributed across a price range:

```
Order Curve: Liquidity distributed continuously

         Liquidity
            ▲
            │      ╭───────╮
            │    ╱           ╲
            │  ╱               ╲
            │╱                   ╲
            └──────────────────────▶ Price
           $140                  $160
           p_min                 p_max

As you fill this order, you smoothly "walk up" the curve.
No discrete jumps = No trigger points = No MEV opportunities.
```

---

## Mathematical Definition

An order curve is defined by a **power-law density function**:

$$
d(p) = k \cdot t(p)^n
$$

Where:
- **p** = price within the range [p_min, p_max]
- **t(p)** = normalized position: (p - p_min) / (p_max - p_min)
- **n** = exponent controlling the density shape
- **k** = normalization constant

<Accordion title="Derivation of the Normalization Constant">

The total liquidity L must equal the integral of density over the price range:

$$
L = \int_{p_{min}}^{p_{max}} d(p) \, dp = \int_0^1 k \cdot t^n \cdot \Delta p \, dt
$$

Solving:

$$
L = k \cdot \Delta p \cdot 1÷(n+1)
$$

Therefore:

$$
k = \frac{L \cdot (n+1)}{\Delta p}
$$

</Accordion>

---

## The Three Core Formulas

Every order curve computation relies on three formulas that convert between fill amounts and prices.

### 1. Cumulative Fill Function F(p)

Given a target price, how much liquidity has been filled?

$$
F(p) = L \cdot t(p)^{n+1}
$$

This is the integral of the density function from p_min to p.

```typescript
// Pseudocode
function cumulativeFill(price: number, order: OrderCurve): number {
  const t = (price - order.pMin) / (order.pMax - order.pMin);
  return order.liquidity * Math.pow(t, order.exponent + 1);
}
```

### 2. Marginal Price Function P_m(f)

Given a fill amount, what is the current marginal (instantaneous) price?

$$
P_m(f) = p_{min} + (p_{max} - p_{min}) \cdot \left(\frac{f}{L}\right)^{\,1/(n+1)}
$$

This is the inverse of the cumulative fill function.

```typescript
// Pseudocode
function marginalPrice(filled: number, order: OrderCurve): number {
  const fillFraction = filled / order.liquidity;
  const tValue = Math.pow(fillFraction, 1 / (order.exponent + 1));
  return order.pMin + (order.pMax - order.pMin) * tValue;
}
```

### 3. Fill-to-Price Function

Given a target price, how much additional fill is needed to reach it?

$$
\Delta f = F(p_{target}) - f_{current}
$$

```typescript
// Pseudocode
function fillToPrice(targetPrice: number, currentFill: number, order: OrderCurve): number {
  const targetFill = cumulativeFill(targetPrice, order);
  return targetFill - currentFill;
}
```

---

## Visualizing Different Exponents

The exponent `n` controls how liquidity is distributed. Since `d(p) = k · t^n`:

<Tabs>
  <Tab title="n = 0 (Uniform)">
    <Frame>
      <svg viewBox="0 0 500 200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="uniformGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#6366f1;stop-opacity:0.8" />
            <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:0.8" />
          </linearGradient>
        </defs>
        <rect x="50" y="20" width="180" height="130" fill="url(#uniformGrad)" rx="2"/>
        <line x1="50" y1="150" x2="230" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="50" y1="20" x2="50" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="140" y="175" textAnchor="middle" fill="#888" fontSize="12">Price</text>
        <text x="30" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,30,85)">Density</text>
        <text x="140" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">d(t) = k · t⁰ = k</text>
        <path d="M 290 150 L 430 20" stroke="#6366f1" strokeWidth="3" fill="none"/>
        <line x1="290" y1="150" x2="430" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="290" y1="20" x2="290" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="360" y="175" textAnchor="middle" fill="#888" fontSize="12">Fill</text>
        <text x="270" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,270,85)">Price</text>
        <text x="360" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">F(t) = L · t</text>
      </svg>
    </Frame>

    **Uniform density**: Liquidity spread evenly across the range. t⁰ = 1 everywhere.

    Best for: Limit orders, flat liquidity provision
  </Tab>
  <Tab title="n = 1 (Linear)">
    <Frame>
      <svg viewBox="0 0 500 200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="linearGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#22c55e;stop-opacity:0.8" />
            <stop offset="100%" style="stop-color:#16a34a;stop-opacity:0.8" />
          </linearGradient>
        </defs>
        <path d="M 50 150 L 230 150 L 230 20 Z" fill="url(#linearGrad)"/>
        <line x1="50" y1="150" x2="230" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="50" y1="20" x2="50" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="140" y="175" textAnchor="middle" fill="#888" fontSize="12">Price</text>
        <text x="30" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,30,85)">Density</text>
        <text x="140" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">d(t) = k · t</text>
        <path d="M 290 150 Q 360 130 430 20" stroke="#22c55e" strokeWidth="3" fill="none"/>
        <line x1="290" y1="150" x2="430" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="290" y1="20" x2="290" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="360" y="175" textAnchor="middle" fill="#888" fontSize="12">Fill</text>
        <text x="270" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,270,85)">Price</text>
        <text x="360" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">F(t) = L · t²</text>
      </svg>
    </Frame>

    **Linear increase**: Density grows linearly toward the range edge.

    Best for: Gradual concentration toward boundary
  </Tab>
  <Tab title="n = 2 (Quadratic)">
    <Frame>
      <svg viewBox="0 0 500 200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="quadGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#f59e0b;stop-opacity:0.8" />
            <stop offset="100%" style="stop-color:#d97706;stop-opacity:0.8" />
          </linearGradient>
        </defs>
        <path d="M 50 150 C 120 150 190 130 230 20 L 230 150 Z" fill="url(#quadGrad)"/>
        <line x1="50" y1="150" x2="230" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="50" y1="20" x2="50" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="140" y="175" textAnchor="middle" fill="#888" fontSize="12">Price</text>
        <text x="30" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,30,85)">Density</text>
        <text x="140" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">d(t) = k · t²</text>
        <path d="M 290 150 C 350 148 400 120 430 20" stroke="#f59e0b" strokeWidth="3" fill="none"/>
        <line x1="290" y1="150" x2="430" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="290" y1="20" x2="290" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="360" y="175" textAnchor="middle" fill="#888" fontSize="12">Fill</text>
        <text x="270" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,270,85)">Price</text>
        <text x="360" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">F(t) = L · t³</text>
      </svg>
    </Frame>

    **Quadratic increase**: More liquidity concentrated toward the upper bound.

    Best for: Mean-reversion strategies, concentrated liquidity at range edges
  </Tab>
  <Tab title="n = 0.5 (Square Root)">
    <Frame>
      <svg viewBox="0 0 500 200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="sqrtGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#ec4899;stop-opacity:0.8" />
            <stop offset="100%" style="stop-color:#db2777;stop-opacity:0.8" />
          </linearGradient>
        </defs>
        <path d="M 50 150 C 80 60 140 35 230 20 L 230 150 Z" fill="url(#sqrtGrad)"/>
        <line x1="50" y1="150" x2="230" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="50" y1="20" x2="50" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="140" y="175" textAnchor="middle" fill="#888" fontSize="12">Price</text>
        <text x="30" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,30,85)">Density</text>
        <text x="140" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">d(t) = k · √t</text>
        <path d="M 290 150 C 310 90 350 40 430 20" stroke="#ec4899" strokeWidth="3" fill="none"/>
        <line x1="290" y1="150" x2="430" y2="150" stroke="#888" strokeWidth="2"/>
        <line x1="290" y1="20" x2="290" y2="150" stroke="#888" strokeWidth="2"/>
        <text x="360" y="175" textAnchor="middle" fill="#888" fontSize="12">Fill</text>
        <text x="270" y="85" textAnchor="middle" fill="#888" fontSize="12" transform="rotate(-90,270,85)">Price</text>
        <text x="360" y="12" textAnchor="middle" fill="#a1a1aa" fontSize="11">F(t) = L · t^1.5</text>
      </svg>
    </Frame>

    **Square root**: Steep initial rise that flattens out. Density increases quickly at first, then slows.

    Best for: Strategies wanting more sensitivity at range start
  </Tab>
</Tabs>

---

## On-Chain Implementation

Braid implements order curves with fixed-point integer arithmetic for deterministic on-chain execution.

### Scaling Constants

```rust
const SCALE: u64 = 1000;              // Exponent scaling
const PRICE_SCALE: u64 = 1_000_000;   // 6 decimal places
const AMOUNT_SCALE: u64 = 1_000_000_000; // 9 decimal places
```

### Power Function

The `power_exp` function computes t^n using scaled integers:

```rust
/// Computes t^n where t and n are scaled by SCALE
/// t_scaled is in range [0, SCALE] representing [0, 1]
/// exponent is scaled by SCALE (e.g., 2000 = n=2)
fn power_exp(t_scaled: u64, exponent: u32) -> u64 {
    // Special case: sqrt (n ≈ 2, so 1/n ≈ 0.5)
    if exponent >= 1800 && exponent <= 2200 {
        return isqrt(t_scaled * SCALE);
    }

    // General case: binary exponentiation
    let mut result = SCALE;
    let mut base = t_scaled;
    let mut exp = exponent;

    while exp > 0 {
        if exp % 2 == 1 {
            result = result * base / SCALE;
        }
        base = base * base / SCALE;
        exp /= 2;
    }

    result
}
```

### Integer Square Root

For the common n=2 case (concentrated liquidity), Braid uses Newton's method:

```rust
/// Integer square root via Newton-Raphson
fn isqrt(n: u64) -> u64 {
    if n == 0 { return 0; }

    let mut x = n;
    let mut y = (x + 1) / 2;

    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }

    x
}
```

---

## Order Types as Curves

All Braid order types are special cases of the order curve framework:

| Order Type | p_min | p_max | Exponent | Interpretation |
|------------|-------|-------|----------|----------------|
| **Limit Order** | price | price | 1 | Delta function at single price |
| **CLMM Order** | range_low | range_high | 1-4 | Concentrated liquidity in range |
| **PropAMM Order** | limit_price | limit_price | 1 | Slot-scoped limit order |
| **CP-AMM** | spot × 0.1 | spot × 10 | ~2 | Approximates x·y=k curve |

### Limit Orders as Degenerate Curves

A limit order at price P is modeled as a curve where p_min = p_max = P:

```
Limit Order @ $150                As Order Curve

ORDERBOOK VIEW:                   CURVE VIEW:
$150.00 ████ 100 SOL              Infinite density at single point
                                  (Dirac delta function)

                                  d(p) = L × δ(p - $150)
```

### CP-AMM as Power-Law Approximation

The constant-product AMM (x·y=k) curve is approximated using n ≈ 2:

```
Actual CP-AMM curve:  P = y/x (hyperbolic)
Approximation:        P = P_spot × (1 + Δf/L)²

The approximation is accurate for small fills relative to reserves.
```

---

## Pro-Rata Matching

Order curves enable **pro-rata matching** - when multiple orders overlap at the same price, fills are distributed proportionally by density:

```
Two overlapping CLMM orders at price $150:

Order A: density = 1000 tokens/dollar
Order B: density = 500 tokens/dollar
Total:   density = 1500 tokens/dollar

Incoming 150 token fill:
  Order A gets: 150 × (1000/1500) = 100 tokens
  Order B gets: 150 × (500/1500) = 50 tokens
```

This eliminates the "race to be first" dynamic that creates MEV in traditional orderbooks.

---

## Key Invariants

The order curve system maintains these invariants:

<Steps>
  <Step title="Fill Monotonicity">
    Fills only increase: `filled(t+1) >= filled(t)`
  </Step>
  <Step title="Price Monotonicity">
    For asks: marginal price increases with fill
    For bids: marginal price decreases with fill
  </Step>
  <Step title="Conservation">
    Sum of all fills equals total input amount (minus fees)
  </Step>
  <Step title="Bounded Compute">
    Operations are O(log n) or O(1), never O(n)
  </Step>
</Steps>

---

## Example: Filling an Order Curve

Let's walk through filling a CLMM order with these parameters:

```
Order Parameters:
  p_min = $140
  p_max = $160
  Liquidity L = 1000 tokens
  Exponent n = 2
  Currently filled: 0
```

**Step 1**: Taker wants to buy 270 tokens

**Step 2**: Calculate ending marginal price
```
f/L = 270/1000 = 0.27
t = (0.27)^(1/3) = 0.6463
P_m = $140 + $20 × 0.6463 = $152.93
```

**Step 3**: Execute fill
```
Tokens received: 270
Average price paid: ~$146.50 (integral of curve)
New marginal price: $152.93
```

**Step 4**: Order state after fill
```
Filled: 270 tokens
Remaining: 730 tokens
Next taker sees marginal price of $152.93
```

<Note>
**Why is average price lower than marginal price?**

The average price is the integral of the price curve from 0 to f, divided by f. Since the curve slopes upward, the average is always less than the ending marginal price.
</Note>

---

## Further Reading

<CardGroup cols={2}>
  <Card title="Matching Engine" icon="gears" href="/concepts/matching-engine">
    How order curves are matched using Newton-Raphson optimization
  </Card>
  <Card title="CLMM Orders" icon="chart-area" href="/orders/clmm-orders">
    Deep dive into concentrated liquidity positions
  </Card>
</CardGroup>
